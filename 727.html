<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script type="text/javascript">
	//6.2.3 解决引用类型值所带来的问题，用借用构造函数
	//使用 apply call 方法来创在新创建的对象上构造函数
	/*
	function  Father() {
		// body...
		this.colors=["red","blue","green"];
	}

	function Son(){

		Father.call(this);
	}

	var  son1=new Son();
	son1.colors.push("black");
	console.log(son1.colors);
	var son2=new  Son();
	console.log(son2.colors);
	*/
//借用构造函数 有个很大的优势 就是子类型构造函数 可以向超类型构造函数中传递参数
//超类型构造函数 
/*
  function  SuperType(name){

  	  this.name=name;
  }
  function  SubType(){
     //继承了  supertype 同时还传递了 参数 
     SuperType.call(this,"nicoco");

     //传入实例属性 
     this.age=29;

  }
  
   var son1=new SubType();
   console.log(son1.name);
   console.log(son1.age);

//超函数
 function  SuperType(name){

     this.name=name;

     this.colors=["red","blue","green"];
 }
  SuperType.prototype.sayName=function(){

  	 alert(this.name);
  }
  
  function SubType(name,age){

      SuperType.call(this,name);

       this.age=age;

  }

  SubType.prototype=new SuperType();


  SubType.prototype.sayage=function(){

  	 alert(this.age);
  }

// 实例化  
  var  son=new  SubType("nicoco","29");
  son.colors.push("black");
  console.log(son.colors);
  console.log(son.sayage());
  console.log(son.sayName());
*/
//6.24 ES5 带来的 新的object.create()来规范化的原型式的调用
//Object.create
//组合寄生式
/*
function  clone(original)(){

    varl  clone=object(original);
    clone.sayHi=function(){

    	alert("Hi");

    };

     return  clone;

}*/
//第7 章  函数表达式 

//arguments.callee  是指向正在执行的函数的指针
  /*
  function factorial(num){

        if(num<=1){

        	return 1;
        }else{


        	return num*arguments.callee(num-1);
        }

  }
  //命名式的函数表达式  来实现效果 
  var  factorial=(function f(num){
       if(num<=1){

       	return 1;
       }else{


       	  return num*f(num-1);
       }

  })
//闭包  

  function  compare(value1,value2){
    if(value1<value2){

    	return -1;
    }else if(value1>value2){

         retrun 1;

    }else{

    	return 0;
    }

  }

  var result=compare(5,10);
  //函数 执行的时候 会创建一个预先包含全局变量兑现的作用域链，这个作用链会保存在内部的scope中，例如compare()函数 先创建一个执行环境  然后通过复制函数 的scope来构建执行环境的作用域链,此外 又有一个活动对象 作为变量对象传入 作用于作用域链的前端 
  //块级作用域 
/*
   function  outputnumbers(count){
       (function (){

         for(var i=0;i<count;i++){

         	alert(i);
         }
      

       })()
        

   }
*/
//闭包是指 有权访问另一个函数作用域中的变量的函数

(function(){
  var now=new Date();
  if(now.getMonth()==6&&now.getDate()==27){

  	alert("happy");
  }


})()





</script>